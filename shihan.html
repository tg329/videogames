<!DOCTYPE html>
<html>

<head>
    <title>Final Project</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        .leaderboard {
            position: absolute;
            top: 20px;
            left: 1000px;
            width: 300px;
            padding: 20px;
        }

        .leaderboard h2 {
            text-align: center;
        }

        .leaderboard .item {
            cursor: pointer;
            padding: 8px;
            margin: 10px 0;
            background: #f3f3f3;
            border-radius: 5px;
            text-align: center;
            transition: background 0.2s;
        }

        .leaderboard .item:hover {
            background: #e0e0e0;
        }

        .leaderboard .item.active {
            background: #d1c4e9;
        }

        .tooltip {
            position: absolute;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 5px;
            display: none;
        }
    </style>
</head>

<body>
    <div class="leaderboard">
        <h2>Top 10 Games based on Metascore</h2>
        <div id="leaderboard-list"></div>
    </div>

    <p>The bubble chart shows the relationship between the release year and the metascore of games. The size of each
        bubble represents the number of games with the same release year and metascore.</p>

    <svg id="scatterplot" height="850" width="800"></svg>

    <script>
        const scattersvg = d3.select("#scatterplot");
        const scatterWidth = scattersvg.attr("width");
        const scatterHeight = scattersvg.attr("height");
        const scatterMargin = { top: 20, right: 20, bottom: 50, left: 100 };

        const scatterAreaWidth = scatterWidth - scatterMargin.left - scatterMargin.right;
        const scatterAreaHeight = scatterHeight - scatterMargin.top - scatterMargin.bottom;

        const scatterChartArea = scattersvg.append("g")
            .attr("transform", `translate(${scatterMargin.left},${scatterMargin.top})`);

        const scatterAnnotations = scatterChartArea.append("g");

        const tooltip = d3.select("body").append("div").attr("class", "tooltip");

        const bubble = async function () {
            const TopMetacritic = await d3.csv("datasets/metacriticFILTERED.csv", d3.autoType);

            TopMetacritic.forEach(d => {
                d.releaseYear = new Date(d.releaseDate).getFullYear();
            });

            const topGames = TopMetacritic.sort((a, b) => b.metascore - a.metascore).slice(0, 10);

            const leaderboard = d3.select("#leaderboard-list");
            leaderboard.selectAll("div")
                .data(topGames)
                .join("div")
                .attr("class", "item")
                .text(d => d.title)
                .on("click", function (event, d) {
                    scatterChartArea.selectAll("circle")
                        .attr("fill", d => colorScale(d.score))
                        .attr("r", d => Math.sqrt(d.count) * 5);

                    leaderboard.selectAll(".item").classed("active", false);
                    d3.select(this).classed("active", true);

                    scatterChartArea.selectAll("circle")
                        .filter(cd => cd.titles.includes(d.title))
                        .attr("fill", "red")
                        .attr("r", d => Math.sqrt(d.count) * 8);
                });

            const scoreScale = d3.scaleLinear()
                .domain([50, 100])
                .range([scatterAreaHeight, 0]);

            const yearExtent = d3.extent(TopMetacritic, d => d.releaseYear);
            const yearScale = d3.scaleLinear()
                .domain([Math.floor(yearExtent[0]), Math.ceil(yearExtent[1])])
                .range([20, scatterAreaWidth]);

            const colorScale = d3.scaleSequential(d3.interpolateBlues)
                .domain([50, 100]);

            scatterAnnotations.append("g")
                .attr("class", "y axis")
                .call(d3.axisLeft(scoreScale).tickFormat(d3.format("")));

            scatterAnnotations.append("g")
                .attr("class", "x axis")
                .attr("transform", `translate(0,${scatterAreaHeight})`)
                .call(d3.axisBottom(yearScale).tickFormat(d3.format("d")));

            scattersvg.append("text")
                .attr("class", "chart-title")
                .attr("x", scatterWidth / 2)
                .attr("y", 20)
                .text("Metascore vs. Release Year");

            scattersvg.append("text")
                .attr("class", "axis-label")
                .attr("x", scatterMargin.left + scatterAreaWidth / 2)
                .attr("y", scatterHeight - 5)
                .text("Release Year");

            scattersvg.append("text")
                .attr("class", "axis-label")
                .attr("x", -(scatterMargin.top + scatterAreaHeight / 2))
                .attr("y", 20)
                .attr("transform", "rotate(-90)")
                .text("Metascore");

            // group data by release year and metascore
            let groupedData = {};

            for (let i = 0; i < TopMetacritic.length; i++) {
                let game = TopMetacritic[i];
                let year = game.releaseYear;
                let score = game.metascore;
                if (!groupedData[year]) {
                    groupedData[year] = {};
                }

                if (!groupedData[year][score]) {
                    groupedData[year][score] = {
                        count: 0,
                        titles: []
                    };
                }
                groupedData[year][score].count += 1;
                groupedData[year][score].titles.push(game.title);
            }
            let data = [];
            for (let year in groupedData) {
                for (let score in groupedData[year]) {
                    let entry = groupedData[year][score];
                    data.push({
                        year: +year,
                        score: +score,
                        count: entry.count,
                        titles: entry.titles.join(", ")
                    });
                }
            }

            scatterChartArea.selectAll("circle")
                .data(data)
                .join("circle")
                .attr("fill", d => colorScale(d.score))
                .attr("cx", d => yearScale(d.year))
                .attr("cy", d => scoreScale(d.score))
                .attr("r", d => Math.sqrt(d.count) * 5) // size based on count
                .on("mouseover", function (event, d) {
                    d3.select(this)
                        .attr("stroke", "black")
                        .attr("stroke-width", 2);

                    tooltip.style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 30) + "px")
                        .style("display", "inline-block")
                        .html(`<strong>Year:</strong> ${d.year}<br/>
                                <strong>Score:</strong> ${d.score}<br/>
                                <strong>Games:</strong> ${d.titles}`);
                })
                .on("mouseout", function () {
                    d3.select(this)
                        .attr("stroke", "none");
                    tooltip.style("display", "none");
                });
        };
        bubble();
    </script>

</body>

</html>