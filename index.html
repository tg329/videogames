<!DOCTYPE html>
<html>

<head>
  <title>Video Games Layoffs</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body {
      background-color: rgb(0, 0, 0);
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      font-family: monospace;
      color: white;
    }

    text {
      fill: white;
    }

    /* HORIZONTAL SCROLL AND HEATMAP ---------------------------------------- */
    .horizontal-scroll {
      flex: 1 1 10%;
      overflow-x: auto;
      display: flex;
      flex-direction: row;
      gap: 20px;
      -ms-overflow-style: none;
      scrollbar-width: none;
      margin-top: 4%;
      /* margin-top: 24px; */
    }

    .horizontal-scroll::-webkit-scrollbar {
      display: none;
    }

    svg {
      flex-shrink: 0;
    }

    .heatmap-legend-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      margin-left: 20px;
      width: 200px;
      margin-top: -6%;
      padding: 10px;
    }

    .heatmap-title {
      margin: 0;
      margin-bottom: 10px;
      font-size: 1.3em;
      color: rgb(255, 108, 108);
    }

    .heatmap-legend {
      flex-shrink: 0;
    }

    .year-container {
      flex-shrink: 0;
    }

    .month-box {
      stroke: rgb(17, 46, 92);
      transition: transform 0.2s ease;
      transform-origin: center;
    }

    .month-box:hover {
      transform: scale(1.02);
      z-index: 100;
      stroke: rgb(209, 253, 201);
      ;
      stroke-width: 2px;
    }

    .calendar-chart {
      display: flex;
      gap: 30px;
    }

    .scroll-progress-container {
      position: relative;
      width: 92vw;
      height: 10px;
      background-color: #4b7159;
      top: -3px;
      /* border-radius: 5px; */
    }

    .scroll-progress-bar {
      height: 100%;
      background-color: rgb(255, 0, 0);
      width: var(--scroll-progress);
      position: absolute;
      top: -2px;
    }

    .scroll-icon {
      position: absolute;
      top: -110px;
      left: calc(var(--scroll-progress) - 35px);
      width: 118px;
      z-index: 100;
    }

    .year-container svg {
      width: auto;
      height: auto;
    }

    .month-label {
      text-align: center;
      fill: rgb(209, 253, 201);
      cursor: default;
      transition: transform 0.2s ease;
    }

    .month-box:hover+.month-label {
      transform: scale(1.03) translate(-1%, -2%);
    }


    /* STATIC GRAPHS -------------------------------------------------------- */
    .static-box {
      display: flex;
      flex: 0 0 6%;
      background-color: lightgray;
      padding: 14vw;
      padding-left: 0px;
      padding-right: 0px;
    }


    /* PAGE TWO ------------------------------------------------------------- */
    .fade-out {
      opacity: 0;
      transition: opacity 0.6s ease;
      pointer-events: none;
    }

    .fade-in {
      opacity: 1;
      transition: opacity 0.6s ease;
      pointer-events: auto;
    }

    #page2 {
      position: fixed;
      top: 0;
      left: 0;
      background-color: black;
      width: 100vw;
      height: 100vh;
      opacity: 0;
      z-index: -1;
      pointer-events: none;
      transition: opacity 0.6s ease;
      margin: 10px;

      display: flex;
      align-items: center;
      justify-content: center;
    }

    #page2.visible {
      opacity: 1;
      z-index: 2;
      pointer-events: auto;
    }

    .static-box.hidden,
    .horizontal-scroll.hidden {
      display: none;
    }

    /* BAR CHART CSS */
    .bar-title {
      text-align: center;
    }
/* 
    .gridlines .domain {
          display: none;
          }
          
      .gridlines line {
          stroke: #9a9a9a;
      } */

    .tooltip {
        pointer-events: none;
        visibility: hidden;
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        transform: translate(-50%, -130%);  /* this is the only way i can translate the text for some reason */
        /* lazy way to make sure tooltip is always on top */
        z-index: 9999;
    }

    .tooltipgame {
        pointer-events: none;
        visibility: hidden;
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        /* lazy way to make sure tooltip is always on top */
        z-index: 9999;
    }




  </style>
</head>

<body>
  <div class="static-box">
    <div class="graph1">
      this is a placeholder. graphs will go here. 
      this is a placeholder. graphs will go here.
      this is a placeholder. graphs will go here. 


    </div>


    <div class="graph2">
      this is a placeholder. graphs will go here. 
      this is a placeholder. graphs will go here.
      this is a placeholder. graphs will go here.

    </div>

  </div>
  <div class="horizontal-scroll" id="scroll-container">
    <!-- legend -->
    <div class="heatmap-legend-container">
      <h2 class="heatmap-title">Yearly Number of Game Releases</h2>
      <svg class="heatmap-legend" width="200" height="40">
        <defs>
          <linearGradient id="legend-gradient">
            <stop offset="0%" stop-color="rgb(190, 229, 183)"></stop>
            <stop offset="100%" stop-color="rgb(0, 68, 27)"></stop>
          </linearGradient>
        </defs>
        <rect x="0" y="10" width="200" height="10" fill="url(#legend-gradient)" />
        <text x="0" y="35" fill="white" font-size="10px">Fewer</text>
        <text x="160" y="35" fill="white" font-size="10px">More</text>
      </svg>
    </div>
    <!-- calendar heatmap -->
    <div class="calendar-chart">

    </div>
  </div>
  <div class="scroll-progress-container">
    <div class="scroll-progress-bar" id="progress-bar"></div>
    <img src="images/moving.gif" alt="link progress" class="scroll-icon" id="progress-icon">
  </div>

  <div class="page" id="page2">

    <div class="bar-display">
      <h2 class="bar-title">Major Game Company Layoffs</h2>
      <svg id="barchart" height="400" width="700"> </svg>
      <div id="tooltip" class="tooltip">
      </div>
      <div id="gameTooltip" class="tooltipgame"></div>
        <svg id="toptimeline" height="300" width="700"> </svg>
    </div>

  </div>



  <script>
    // ----------- CALENDAR HEATMAP START -----------------------------------
    d3.csv("datasets/metacritic-time.csv", row => {

      const parsedDate = new Date(row.releaseDate);
      const releaseYear = parsedDate.getFullYear();
      if (releaseYear < 2020) return null;

      return {
        year: releaseYear,
        month: parsedDate.getMonth()
      };
    }).then(data => {
      const releaseCountsByYearMonth = d3.rollup(
        data,
        group => group.length,
        d => d.year,
        d => d.month
      );

      const years = Array.from(releaseCountsByYearMonth.keys()).sort();
      const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];


      const maxGameCount = d3.max(Array.from(releaseCountsByYearMonth.values(), monthMap =>
        d3.max(Array.from(monthMap.values()))
      ));

      const colorScale = d3.scaleSequential(d3.interpolateGreens)
        .domain([0, maxGameCount]);

      // set calendar box size here
      const monthBoxSize = 100;
      const monthsPerRow = 6;
      const yearBoxWidth = monthBoxSize * monthsPerRow;
      const yearBoxHeight = monthBoxSize * 2 + 20; // 2 rows of months

      const chartContainer = d3.select(".calendar-chart");


      // one calendar box per year
      years.forEach(year => {
        const monthlyCounts = releaseCountsByYearMonth.get(year);

        const yearContainer = chartContainer.append("div")
          .attr("class", "year-container");

        const heatmapSvg = yearContainer.append("svg")
          .attr("width", yearBoxWidth)
          .attr("height", yearBoxHeight + 20);

        heatmapSvg.append("text")
          .attr("x", yearBoxWidth / 2)
          .attr("y", 12)
          .text(year)
          .attr("class", "label");

        // 12 month boxes
        for (let monthIndex = 0; monthIndex < 12; monthIndex++) {
          const col = monthIndex % monthsPerRow;
          const row = Math.floor(monthIndex / monthsPerRow);

          const x = col * monthBoxSize;
          const y = row * monthBoxSize + 20;

          const count = monthlyCounts?.get(monthIndex) || 0;

          heatmapSvg.append("rect")
            .attr("x", x)
            .attr("y", y)
            .attr("width", monthBoxSize)
            .attr("height", monthBoxSize)
            .attr("fill", colorScale(count))
            .attr("class", "month-box");

          heatmapSvg.append("text")
            .attr("x", x + monthBoxSize / 2)
            .attr("y", y + monthBoxSize / 2)
            .attr("dy", ".35em")
            .attr("dx", "-1em")
            .text(monthNames[monthIndex])
            .attr("class", "month-label");

        }
      });
    });


    // SCROLL BAR --
    const scrollContainer = document.getElementById("scroll-container");
    const page2 = document.getElementById("page2");
    const staticBox = document.querySelector(".static-box");
    const calendar = document.querySelector(".horizontal-scroll");
    const progressIcon = document.getElementById("progress-icon");

    let onPage2 = false;

    scrollContainer.addEventListener("scroll", () => {
      const content = scrollContainer.querySelector(".calendar-chart");
      const maxScrollLeft = content.scrollWidth - scrollContainer.clientWidth;
      const scrollLeft = scrollContainer.scrollLeft;
      const progress = scrollLeft / maxScrollLeft;

      const icon = document.getElementById("progress-icon");
      const bar = document.getElementById("progress-bar");

      const containerWidth = scrollContainer.clientWidth;
      const iconWidth = icon.offsetWidth;
      const maxLeft = containerWidth - iconWidth;
      bar.style.width = `${progress * 100}%`;
      const clampedLeft = Math.min(maxLeft, Math.max(0, progress * containerWidth - iconWidth / 2));
      icon.style.left = `${clampedLeft}px`;

      // page 2
      if (progress >= 0.99 && !onPage2) {
        onPage2 = true;
        staticBox.classList.remove("fade-in");
        calendar.classList.remove("fade-in");
        staticBox.classList.add("fade-out");
        calendar.classList.add("fade-out");

        page2.classList.add("visible");
        progressIcon.src = "images/idle.gif";
      }

      // page 1
      if (progress < 0.99 && onPage2) {
        onPage2 = false;
        staticBox.classList.remove("fade-out");
        calendar.classList.remove("fade-out");
        staticBox.classList.add("fade-in");
        calendar.classList.add("fade-in");

        page2.classList.remove("visible");
        progressIcon.src = "images/moving.gif";
      }
    });

    // will horizontal scroll no matter where on page
    document.addEventListener("wheel", function (e) {
      const isHorizontalScroll = Math.abs(e.deltaX) > Math.abs(e.deltaY);
      if (isHorizontalScroll || e.shiftKey) {
        const scrollContainer = document.getElementById("scroll-container");
        scrollContainer.scrollLeft += e.deltaY + e.deltaX;
        e.preventDefault();
      }
    }, { passive: false });

    // ----------- CALENDAR HEATMAP END -----------------------------------

    ////////////////////////////////////////////////////////////////////////////
    ////// PAGE 2
    ////////////////////////////////////////////////////////////////////////////

    // ----------- BARCHART START -----------------------------------------
    const barsvg = d3.select("#barchart");
    const barWidth = barsvg.attr("width");
    const barHeight = barsvg.attr("height");
    const barMargin = { top: 20, right: 60, bottom: 130, left: 60 };

    const barAreaWidth = barWidth - barMargin.left - barMargin.right;
    const barAreaHeight = barHeight - barMargin.top - barMargin.bottom;

    const barChartArea = barsvg.append("g")
      .attr("transform", "translate(" + (barMargin.left) + "," + barMargin.top + ")");

    const annotations = barChartArea.append('g')

     // ----------- LINECHART/TIMELINE START -----------------------------------------

     const timelinesvg = d3.select("#toptimeline");
    const timelineWidth = timelinesvg.attr("width");
    const timelineHeight = timelinesvg.attr("height");
    const timelineMargin = {top: 10, right: 60, bottom: 130, left: 60};

    const timelineAreaWidth = timelineWidth - timelineMargin.left - timelineMargin.right;
    const timelineAreaHeight = timelineHeight - timelineMargin.top - timelineMargin.bottom;

    const timelineChartArea = timelinesvg.append("g")
        .attr("transform", "translate("+(timelineMargin.left)+","+timelineMargin.top+")");

    const timelineAnnotations = timelineChartArea.append('g')

    const requestBarChartData = async function () {

      majorLayoffs = await d3.csv("datasets/majorLayoffs.csv", d3.autoType)
      companies = []
      majorLayoffs.forEach(d => {
        companies.push(d.Company);
      });

      // Y axis: Counts
      layoffMax = d3.max(majorLayoffs, d => d["Number of Layoffs"])
      layoffExtent = d3.extent([0, layoffMax])

      const countScale = d3.scaleLinear()
        .domain(layoffExtent)
        .range([barAreaHeight, 0])

      let leftAxis = d3.axisLeft(countScale)
        .tickFormat(d3.format("~f")) // no commas

      let leftGridlines = d3.axisLeft(countScale)
        .tickSize(-barAreaWidth + 10)
        .tickFormat("")

      annotations.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${-10},${0})`)
        .call(leftAxis)

      annotations.append("g")
        .attr("class", "y gridlines")
        .attr("transform", `translate(${-10},${0})`)
        .call(leftGridlines);

      // X axis: Years
      const companyScale = d3.scaleBand()
        .domain(companies)
        .range([0, barAreaWidth])
        .padding(0.05)

      let bottomAxis = d3.axisBottom(companyScale)

      annotations.append('g')
        .attr('class', 'x axis')
        .attr("transform", `translate(0,${barAreaHeight + 1})`)
        .call(bottomAxis)
        .selectAll("text")
        .attr("transform", "translate(-5,0)rotate(-40)")
        .style("text-anchor", "end")
        .style("font-size", 12)

      // draw bars
      layoffBars = barChartArea.selectAll('rect.layoff').data(majorLayoffs)
        .join('rect')
        .attr('class', 'bar')
        .attr('fill', 'black')
        .attr('x', d => companyScale(d['Company']))
        .attr('y', d => countScale(d['Number of Layoffs']))
        .attr('height', d => countScale(layoffExtent[0]) - countScale(d["Number of Layoffs"]))
        .attr('width', companyScale.bandwidth())
        .attr('company', d => d['Company'])

      // add circles to bars to represent a single person
      function getCircleRadius() {
        selectedBar = layoffBars.filter(d => d['Company'] === companies[0])
        height = selectedBar.attr('height')
        width = selectedBar.attr('width')
        numCircles = selectedBar.datum()['Number of Layoffs']
        diameter = Math.sqrt((height * width) / (numCircles))
        return diameter / 2
      }

      // calculate circle radius
      function drawCircles(company, radius) {
        diameter = radius * 2
        selectedBar = layoffBars.filter(d => d['Company'] === company)
        height = selectedBar.attr('height')
        width = selectedBar.attr('width')
        numCircles = selectedBar.datum()['Number of Layoffs']

        // number of circles per row
        perRow = Math.ceil(width / diameter)
        data = Array(numCircles)
        startX = companyScale(company) + radius
        startY = countScale(0) - radius

        circles = barChartArea.selectAll('circles.layoff').select(company).data(data)
          .join(
            enter => enter.append('circle')
              .attr("fill", 'steelblue')
              .attr("cx", (d, i) => startX + (diameter * (i % perRow)))
              .attr("cy", (d, i) => startY - (diameter * Math.floor(i / perRow)))
              .attr("r", radius)
          )

        circles.on("mouseover", function (event, d) {
          d3.select(this)
            .transition()
            .duration(28)
            .attr("r", radius * 4)
        }).on("mouseout", function (event, d) {
          d3.select(this)
            .transition()
            .duration(1350)
            .attr("r", radius)
        })


      }
      let radius = getCircleRadius();
      companies.forEach(d => {
        drawCircles(d, radius)
      });

      // HOVERS
      const tooltip = d3.select("#tooltip");
      layoffBars.on("mouseover", function (event, d) {
        const rect = this.getBoundingClientRect(); // Get screen position of the bar
        tooltip
          .style("visibility", "visible")
          .style("opacity", 1)
          .html(`<strong># Layoffs:</strong> ${d["Number of Layoffs"]}`)
          .style("left", `${rect.left + rect.width / 2}px`)
          .style("top", `${rect.top}px`); // 40px above the bar

          requestTimelineData(d["Company"]);

      }).on("mouseout", function (event, d) {
        // we cant have mouseovers for 2 things at once. Have the tooltuip appear when entering the rect, stay there until another rect is moused over. 
      })

      // SET UP FOR TIMELINE (CONSTANTS) ------------------------------------------------------------------------------------------------------

      companyLayoffs = await d3.csv("datasets/all-layoffs.csv", d3.autoType)
      companyGames = await d3.csv("datasets/metacriticFILTERED.csv", d3.autoType)

      const parseDate = d3.timeParse("%Y-%m-%d");
      companyLayoffs.forEach(d => d.date = parseDate(d.date));

      company = "null";
      selectedCompanyLayoffs = companyLayoffs.filter(d => d['Parent'] ? d['Parent'].includes(company) : false)
      selectedCompanyGames = companyGames.filter(d => d['publisher'].includes(company))

      // Y axis: Counts
      companyLayoffExtent = d3.extent([0, d3.max(selectedCompanyLayoffs, d=>d["Headcount"])])

      headcountScale = d3.scaleLinear()
          .range([timelineAreaHeight, 0])
      
      timelineAnnotations.append("g")
          .attr("class", "y-axis-left-TL")
          .attr("transform",`translate(${-10},${0})`)

      // X axis: Years
        
      yearExtent = d3.extent(selectedCompanyLayoffs, d => d['Date']);
      yearScale = d3.scaleLinear()
          .range([0, timelineAreaWidth]); 

      timelineAnnotations.append('g')
          .attr('class', 'x-axis-TL')
          .attr("transform",`translate(0,${timelineAreaHeight + 1})`)
      
      // Draw trend line

      timelineChartArea.append("path")
          .attr("class", "line-TL")
          .attr("fill", "none")  
          .attr("stroke", "steelblue")
          .attr("stroke-width", 2)

        // draw bars

        width = 12;
        companylayoffBars = timelineChartArea.selectAll('rect.layoffs').data(selectedCompanyLayoffs)
          .join('rect')
          .attr("class", 'layoffs')
          .attr('fill', 'steelblue')
          .attr('x', d => yearScale(d['Date']) - width/2)
          .attr('y', d => headcountScale(d['Headcount'] ? d['Headcount'] : 0))
          .attr('height', d => headcountScale(companyLayoffExtent[0]) - headcountScale(d['Headcount'] ? d['Headcount'] : 0))
          .attr('width', width)

        // add dots to graph to indicate news

        // let newsSources = timelineChartArea.selectAll("circles.news").data(selectedCompanyLayoffs)
        //     .join("circle")
        //     .attr("fill", "steelblue")
        //     .attr('cy', d => headcountScale(d['Headcount'] ? d['Headcount'] : 0))
        //     .attr('cx', d=> yearScale(d['Date']))
        //     .attr('r', width/2)

        // add vertical line for unclear layoff numbers
        verticalLines = timelineChartArea.selectAll("line.news").data(selectedCompanyLayoffs)
              .join("line")
              .attr("class", "news")
              .attr('stroke-width', 2)
              .attr('opacity', 1)
              .attr('stroke', 'orange')
              .style("stroke-dasharray", ("3, 3"))  // <== This line here!!
              .attr('x1', d=>  d['Headcount'] ? 0 : yearScale(d['Date'])) // if no headcount, place a line at the corresponding date
              .attr('y1', headcountScale(0))
              .attr('x2', d=> d['Headcount'] ? 0 : yearScale(d['Date']))
              .attr('y2', headcountScale(companyLayoffExtent[1]))

        // Second Y Axis: Games

        metacriticExtent = d3.extent(selectedCompanyGames, d=>d["metascore"])

        metacriticScale = d3.scaleLinear()
            .range([timelineAreaHeight, 0])

        timelineAnnotations.append("g")
            .attr("class", "y-axis-right-TL")
            .attr("transform",`translate(${timelineAreaWidth},${0})`)

        let gameCircles = timelineChartArea.selectAll("circle.gamesTL").data(selectedCompanyGames)
            .join("circle")
            .attr("class", "gamesTL")
            .attr('cy', d => metacriticScale(d["metascore"]))
            .attr('cx', d=> yearScale(d['releaseDate']))
            .attr('r', 3)
            .attr('fill', 'white')


        // Hover Controls   

        TLtooltip = d3.select("#gameTooltip");

        gameCircles.on("mouseover", function (event, d) {

            d3.select(this)
                .attr('r', 5)

            const rect = this.getBoundingClientRect(); // Get screen position of the bar

            TLtooltip
                .style("visibility", "visible")
                .style("opacity", 1)
                .html(`<strong> ${d["title"]} </strong>: ${d['metascore']} `)
                .style("left", `${rect.right + 10}px`)
                .style("top", `${rect.top + rect.height / 2}px`); // 40px above the bar
        
            
        }).on("mouseout", function(event, d) {

            d3.select(this)
                .attr('r', 3)

            TLtooltip
            .style("visibility", "visible")
            .style("opacity", 0)

        })


        companylayoffBars.on("mouseover", function (event, d) {

            d3.select(this)
                .attr('r', 5)

            const rect = this.getBoundingClientRect(); // Get screen position of the bar

            TLtooltip
                .style("visibility", "visible")
                .style("opacity", 1)
                .html(`<strong> Layoffs </strong>: ${d['Headcount']} `)
                .style("left", `${rect.right + 10}px`)
                .style("top", `${rect.top + rect.height / 2}px`); // 40px above the bar


        }).on("mouseout", function(event, d) {

            d3.select(this)
                .attr('r', 4)

            TLtooltip
            .style("visibility", "visible")
            .style("opacity", 0)

        })


    requestTimelineData = function(company) {
        
        selectedCompanyLayoffs = companyLayoffs.filter(d => d['Parent'] ? d['Parent'].includes(company) || company.includes(d['Parent']) : false)
        selectedCompanyGames = companyGames.filter(d => d['publisher'].includes(company) || company.includes(d['publisher']))
        // selectedCompanyGames.forEach(d => d['releaseDate'] = parseDate(d['releaseDate']));

        // Y axis: Counts
        companyLayoffExtent = d3.extent([0, d3.max(selectedCompanyLayoffs, d=>d["Headcount"])])
        headcountScale.domain(companyLayoffExtent)
        
        TLleftAxis = d3.axisLeft(headcountScale)
            .tickFormat(d3.format("~f")) // no commas
        
        d3.select(".y-axis-left-TL")
          .transition()
          .duration(300)
          .call(TLleftAxis);
              
        yearExtent = d3.extent(selectedCompanyLayoffs, d => d['Date']);
        yearScale.domain(yearExtent)

        TLbottomAxis = d3.axisBottom(yearScale)
        .tickFormat(d3.timeFormat("%Y"));
        // .tickFormat(d3.format("~f"));  // exact value without commas   
        
        d3.select(".x-axis-TL")
          .transition()
          .duration(300)
          .call(TLbottomAxis);
        
        // Draw trend line

        var lineGen = d3.line()
            .x( d => yearScale(d['Date']) )
            .y( d => headcountScale(d['Headcount'] ? d['Headcount'] : 0) )
            // .curve(d3.curveMonotoneX);  
        
        d3.select(".line-TL")
            .datum(selectedCompanyLayoffs)
            .attr("d", lineGen);

        // draw bars

        width = 12;
        companylayoffBars= timelineChartArea.selectAll('rect.layoffs').data(selectedCompanyLayoffs)
          .join('rect')
          .attr("class", 'layoffs')
          .attr('fill', 'steelblue')
          .attr('x', d => yearScale(d['Date']) - width/2)
          .attr('y', d => headcountScale(d['Headcount'] ? d['Headcount'] : 0))
          .attr('height', d => headcountScale(companyLayoffExtent[0]) - headcountScale(d['Headcount'] ? d['Headcount'] : 0))
          .attr('width', width)

        // add dots to graph to indicate news

        // let newsSources = timelineChartArea.selectAll("circles.news").data(selectedCompanyLayoffs)
        //     .join("circle")
        //     .attr("fill", "steelblue")
        //     .attr('cy', d => headcountScale(d['Headcount'] ? d['Headcount'] : 0))
        //     .attr('cx', d=> yearScale(d['Date']))
        //     .attr('r', width/2)

        // add vertical line for unclear layoff numbers
        verticalLines = timelineChartArea.selectAll("line.news").data(selectedCompanyLayoffs)
              .join("line")
              .attr("class", "news")
              .attr('stroke-width', 2)
              .attr('opacity', 1)
              .attr('stroke', 'orange')
              .style("stroke-dasharray", ("3, 3"))  // <== This line here!!
              .attr('x1', d=>  d['Headcount'] ? 0 : yearScale(d['Date'])) // if no headcount, place a line at the corresponding date
              .attr('y1', headcountScale(0))
              .attr('x2', d=> d['Headcount'] ? 0 : yearScale(d['Date']))
              .attr('y2', headcountScale(companyLayoffExtent[1]))

        // Second Y Axis: Games

        metacriticExtent = d3.extent(selectedCompanyGames, d=>d["metascore"])
        metacriticScale.domain(metacriticExtent)
      
        let rightAxis = d3.axisRight(metacriticScale)
            .tickFormat(d3.format("~f")) // no commas

        d3.select(".y-axis-right-TL")
          .transition()
          .duration(300)
          .call(rightAxis);

        let gameCircles = timelineChartArea.selectAll("circle.gamesTL")
            .data(selectedCompanyGames)
            .join("circle")
            .attr("class", "gamesTL")
            .attr('cy', d => metacriticScale(d["metascore"]))
            .attr('cx', d=> yearScale(d['releaseDate']))
            .attr('r', 3)
            .attr('fill', 'white')


        // Hover Controls   

        const tooltip = d3.select("#gameTooltip");

        gameCircles.on("mouseover", function (event, d) {

            d3.select(this)
                .attr('r', 5)

            const rect = this.getBoundingClientRect(); // Get screen position of the bar

            tooltip
                .style("visibility", "visible")
                .style("opacity", 1)
                .html(`<strong> ${d["title"]} </strong>: ${d['metascore']} `)
                .style("left", `${rect.right + 10}px`)
                .style("top", `${rect.top + rect.height / 2}px`); // 40px above the bar
        
            
        }).on("mouseout", function(event, d) {

            d3.select(this)
                .attr('r', 3)

            tooltip
            .style("visibility", "visible")
            .style("opacity", 0)

        })


        companylayoffBars.on("mouseover", function (event, d) {

            d3.select(this)
                .attr('r', 5)

            const rect = this.getBoundingClientRect(); // Get screen position of the bar

            tooltip
                .style("visibility", "visible")
                .style("opacity", 1)
                .html(`<strong> Layoffs </strong>: ${d['Headcount']} `)
                .style("left", `${rect.right + 10}px`)
                .style("top", `${rect.top + rect.height / 2}px`); // 40px above the bar


        }).on("mouseout", function(event, d) {

            d3.select(this)
                .attr('r', 4)

            tooltip
            .style("visibility", "visible")
            .style("opacity", 0)

        })
        
    }


    // requestTimelineData("Electronic Arts");
  }

    requestBarChartData();
    



  </script>

</body>

</html>